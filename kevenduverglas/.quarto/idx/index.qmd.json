{"title":"Professional Précis","markdown":{"yaml":{"title":"Professional Précis","subtitle":"Author: (Keven M. Duverglas)"},"headingText":"About the Author","containsRefs":false,"markdown":"\n\n\nHello my name is Keven Michel Duverglas, and I am Sophmore at Allegheny. A fun fact about me is that I can speak three language.\nI am looking forward to collaborating with everyone throughout the semester and get to know the dev-team well.\n\n\n# Week 1\n\n## SE1\n\n#### Summary\n\nThere's an exploration of what exactly\n\"software engineering\" means, and the reading distinguishes it not only\nfrom fields like programming and computer science but also\nshedding light on how it stands in relation to other disciplines\nwith \"engineering\" in their title. It also speaks on the matters regarding the \ngrowth of organizations and release new software. \n\n#### Reflection\n\nI am firmly convinced that this book provides insights into crafting efficient code.\nThese insights offer practical advice on how to refine one's\ncoding practices for the long term. One of the standout aspects of the book is its emphasis\non reducing redundancy in code, which not only makes the code cleaner but also easier to maintain. \n\n#### Use-Case\n\nThis book provides the tools for us to run code, allowing Chasten to evaluate and utilize it within a test-case setting.\n\n## FB1\n\n#### Summary\n\nThe initial chapter introduces core concepts of software testing, addressing the necessity,\nmethods, and assessment of software testing. Using Python and interactive notebooks, readers\nare familiarized with these principles. The chapter provides a basic my_sqrt() function, which\naims to compute the square root of a given number. A brief overview\nof understanding Python's structure and syntax is provided, followed by a practical demonstration of\nrunning the function. Readers can directly experiment with the\nfunction and observe results, while also making edits to the provided content. And this can be done through a Jupyter \nNotebook.\n\n#### Reflection\n\nThis chapter provided a comprehensive look into the world of software testing,\noffering both theoretical knowledge and hands-on tools for practical implementation.\nOne of the intriguing parts for me was the example on testing the my_sqrt() function. Implementing a square root\nfunction might appear elementary,\nbut the emphasis on the Newton–Raphson method highlighted the process behind it.\n\n#### Use-Case\n\nThe first chapter of the Fuzzing book does a solid job of laying down the basics.\nIt sets the stage for the kind of deep thinking we'll need when we start building the\nChasten tool. By mixing theory with hands-on examples, readers get a good grasp of what's\nahead. This foundation is key, making sure everyone's on the same page as we dive into the\nmore complex parts of the book.\nIt's clear that this chapter is an essential starting point for everything that follows.\n\n\n# Week 2\n\n## SE2\n\n#### Summary\n\nThe article contrasts programming with software engineering, emphasizing three primary distinctions:\ntime, scale, and trade-offs. Time emerges as a crucial factor, with software engineering often focusing\non projects with extended lifespans that shifts in technology or business trends.\nUnlike standalone programming tasks, software engineering is inherently collaborative, \nchallenges related to team dynamics, project\nmanagement, and organizational policies. As projects and teams expand, maintaining efficiency is vital.\nFurthermore, the discipline of software engineering demands intricate decision-making. Engineers face\ncomplex trade-offs, frequently operating within an environment of differing metrics.\n\n#### Reflection\n\nReading this, I can resonate with the aspects of drawbacks and trade-offs in software engineering.\nThis is evident in class where many of my colleagues often have to decide which tasks are more crucial\nto complete. Additionally, time significantly influences our work ethic and decision-making.\nIt's a constant balance of prioritizing immediate needs against long-term objectives.\n\n#### Use-Case\n\nDuring our software development, it's crucial to evaluate the trade-offs of our programming choices.\nUnderstanding the advantages and disadvantages before deployment is vital to ensure we don't\nintroduce issues into our code, and also intergate time-keeping as a habit.\n\n## FB2\n\n#### Summary\n\nTo achieve nearly perfect code coverage, we utilize a technique known as fuzzing.\nFuzzing involves generating random characters to test various input scenarios.\nThis method helps generate potential outcomes for different functions,\nlike the provided example of the cgi_decode function.\nThrough this, we determine the necessary inputs\nto achieve comprehensive code coverage in our tests.\n\n#### Reflection\n\nImplementing such testing mechanisms proves invaluable for identifying\nmaximum coverage using random fuzzing inputs. It's particularly effective\nin discovering edge cases in extensive programs with myriad input possibilities.\nHowever, it's a time-consuming approach. Hence,\nit's crucial to employ this technique only for large-scale programs that can't be\nmanually vetted, ensuring optimal time management.\n\n#### Use-Case\n\nFor our chasten tool, incorporating these tests is paramount,\nespecially as we plan to introduce numerous features throughout the term.\nIt's crucial to ensure thorough coverage before releasing the software.\nIf we decide to implement this testing methodology, we must\nbe prepared to allocate substantial classroom time and personnel to it.\n\n# Week 3\n\n## SE3\n\n#### Summary\n\nThis chapter delves into the infrastructure of a software engineering team, emphasizing the pivotal role of\nteamwork in achieving remarkable results and highlighting the significance of self-awareness within the team.\nThe chapter discusses the trade-offs of working alone in software\ndevelopment, including prolonged struggles and delayed error detection.\nIt also introduces the concept of collaborative nirvana, focusing on three\npillars of social interaction: humility, respect, and trust.\nThe action items suggested include regular team meetings and check-ins,\npeer mentoring and knowledge sharing, as well as the importance of acknowledging\neach team member's strengths, celebrating success, and learning from failures.\n\n#### Reflection\n\nThis chapter underscores the critical importance of collaboration and self-awareness\nin software engineering teams. It serves as a reminder that working in isolation can\nlead to challenges and hinder progress.\nEmbracing humility, respect, and trust as guiding principles for social interaction\ncan unlock the full potential of teamwork.\n\n#### Use-Case\n\nThe insights and recommendations from this chapter can be applied\nin various scenarios within a software engineering team. For instance,\nteams can implement regular meetings and check-ins to foster communication\nand collaboration. Peer mentoring and knowledge sharing can be encouraged to\nfacilitate skill development and information exchange. Additionally,\nacknowledging the strengths of each team member,\ncelebrating achievements, and using failures as opportunities for\nlearning can help create a positive and productive team culture.\n\n## FB3\n\n#### Summary\n\nFuzzing is a dynamic testing technique employed to discover defects by generating\na wide array of random inputs and subjecting them relentlessly to a target application.\nThe primary aim is to stress-test the software and unearth unexpected vulnerabilities.\nThis chapter delves into the benefits of fuzzing,\nthe roles of the fuzzer and runner components, and the advantages of applying fuzz testing to external programs.\n\n#### Reflection\n\nThe concept of fuzzing is a powerful tool in the software testing arsenal.\nBy inundating an application with diverse and often unpredictable inputs,\nfuzzing can reveal vulnerabilities that traditional testing methods might overlook. Understanding the mechanics of fuzzing,\nsuch as the fuzzer and runner components, allows testers to tailor their approach to the specific needs of the application.\n\n#### Use-Case\n\nFuzzing is an invaluable technique for identifying vulnerabilities in\nsoftware. The benefits of fuzz testing include uncovering issues like\nbuffer overflows, crashes, and security vulnerabilities. To implement\nfuzzing, the fuzzer component can be customized to generate various \ntypes of inputs, such as numbers or characters. The runner component plays\na critical role in executing the target application with the generated inputs\nand monitoring its behavior.\n\n\n\n\n\n\n\n\n\n","srcMarkdownNoYaml":"\n\n# About the Author\n\nHello my name is Keven Michel Duverglas, and I am Sophmore at Allegheny. A fun fact about me is that I can speak three language.\nI am looking forward to collaborating with everyone throughout the semester and get to know the dev-team well.\n\n\n# Week 1\n\n## SE1\n\n#### Summary\n\nThere's an exploration of what exactly\n\"software engineering\" means, and the reading distinguishes it not only\nfrom fields like programming and computer science but also\nshedding light on how it stands in relation to other disciplines\nwith \"engineering\" in their title. It also speaks on the matters regarding the \ngrowth of organizations and release new software. \n\n#### Reflection\n\nI am firmly convinced that this book provides insights into crafting efficient code.\nThese insights offer practical advice on how to refine one's\ncoding practices for the long term. One of the standout aspects of the book is its emphasis\non reducing redundancy in code, which not only makes the code cleaner but also easier to maintain. \n\n#### Use-Case\n\nThis book provides the tools for us to run code, allowing Chasten to evaluate and utilize it within a test-case setting.\n\n## FB1\n\n#### Summary\n\nThe initial chapter introduces core concepts of software testing, addressing the necessity,\nmethods, and assessment of software testing. Using Python and interactive notebooks, readers\nare familiarized with these principles. The chapter provides a basic my_sqrt() function, which\naims to compute the square root of a given number. A brief overview\nof understanding Python's structure and syntax is provided, followed by a practical demonstration of\nrunning the function. Readers can directly experiment with the\nfunction and observe results, while also making edits to the provided content. And this can be done through a Jupyter \nNotebook.\n\n#### Reflection\n\nThis chapter provided a comprehensive look into the world of software testing,\noffering both theoretical knowledge and hands-on tools for practical implementation.\nOne of the intriguing parts for me was the example on testing the my_sqrt() function. Implementing a square root\nfunction might appear elementary,\nbut the emphasis on the Newton–Raphson method highlighted the process behind it.\n\n#### Use-Case\n\nThe first chapter of the Fuzzing book does a solid job of laying down the basics.\nIt sets the stage for the kind of deep thinking we'll need when we start building the\nChasten tool. By mixing theory with hands-on examples, readers get a good grasp of what's\nahead. This foundation is key, making sure everyone's on the same page as we dive into the\nmore complex parts of the book.\nIt's clear that this chapter is an essential starting point for everything that follows.\n\n\n# Week 2\n\n## SE2\n\n#### Summary\n\nThe article contrasts programming with software engineering, emphasizing three primary distinctions:\ntime, scale, and trade-offs. Time emerges as a crucial factor, with software engineering often focusing\non projects with extended lifespans that shifts in technology or business trends.\nUnlike standalone programming tasks, software engineering is inherently collaborative, \nchallenges related to team dynamics, project\nmanagement, and organizational policies. As projects and teams expand, maintaining efficiency is vital.\nFurthermore, the discipline of software engineering demands intricate decision-making. Engineers face\ncomplex trade-offs, frequently operating within an environment of differing metrics.\n\n#### Reflection\n\nReading this, I can resonate with the aspects of drawbacks and trade-offs in software engineering.\nThis is evident in class where many of my colleagues often have to decide which tasks are more crucial\nto complete. Additionally, time significantly influences our work ethic and decision-making.\nIt's a constant balance of prioritizing immediate needs against long-term objectives.\n\n#### Use-Case\n\nDuring our software development, it's crucial to evaluate the trade-offs of our programming choices.\nUnderstanding the advantages and disadvantages before deployment is vital to ensure we don't\nintroduce issues into our code, and also intergate time-keeping as a habit.\n\n## FB2\n\n#### Summary\n\nTo achieve nearly perfect code coverage, we utilize a technique known as fuzzing.\nFuzzing involves generating random characters to test various input scenarios.\nThis method helps generate potential outcomes for different functions,\nlike the provided example of the cgi_decode function.\nThrough this, we determine the necessary inputs\nto achieve comprehensive code coverage in our tests.\n\n#### Reflection\n\nImplementing such testing mechanisms proves invaluable for identifying\nmaximum coverage using random fuzzing inputs. It's particularly effective\nin discovering edge cases in extensive programs with myriad input possibilities.\nHowever, it's a time-consuming approach. Hence,\nit's crucial to employ this technique only for large-scale programs that can't be\nmanually vetted, ensuring optimal time management.\n\n#### Use-Case\n\nFor our chasten tool, incorporating these tests is paramount,\nespecially as we plan to introduce numerous features throughout the term.\nIt's crucial to ensure thorough coverage before releasing the software.\nIf we decide to implement this testing methodology, we must\nbe prepared to allocate substantial classroom time and personnel to it.\n\n# Week 3\n\n## SE3\n\n#### Summary\n\nThis chapter delves into the infrastructure of a software engineering team, emphasizing the pivotal role of\nteamwork in achieving remarkable results and highlighting the significance of self-awareness within the team.\nThe chapter discusses the trade-offs of working alone in software\ndevelopment, including prolonged struggles and delayed error detection.\nIt also introduces the concept of collaborative nirvana, focusing on three\npillars of social interaction: humility, respect, and trust.\nThe action items suggested include regular team meetings and check-ins,\npeer mentoring and knowledge sharing, as well as the importance of acknowledging\neach team member's strengths, celebrating success, and learning from failures.\n\n#### Reflection\n\nThis chapter underscores the critical importance of collaboration and self-awareness\nin software engineering teams. It serves as a reminder that working in isolation can\nlead to challenges and hinder progress.\nEmbracing humility, respect, and trust as guiding principles for social interaction\ncan unlock the full potential of teamwork.\n\n#### Use-Case\n\nThe insights and recommendations from this chapter can be applied\nin various scenarios within a software engineering team. For instance,\nteams can implement regular meetings and check-ins to foster communication\nand collaboration. Peer mentoring and knowledge sharing can be encouraged to\nfacilitate skill development and information exchange. Additionally,\nacknowledging the strengths of each team member,\ncelebrating achievements, and using failures as opportunities for\nlearning can help create a positive and productive team culture.\n\n## FB3\n\n#### Summary\n\nFuzzing is a dynamic testing technique employed to discover defects by generating\na wide array of random inputs and subjecting them relentlessly to a target application.\nThe primary aim is to stress-test the software and unearth unexpected vulnerabilities.\nThis chapter delves into the benefits of fuzzing,\nthe roles of the fuzzer and runner components, and the advantages of applying fuzz testing to external programs.\n\n#### Reflection\n\nThe concept of fuzzing is a powerful tool in the software testing arsenal.\nBy inundating an application with diverse and often unpredictable inputs,\nfuzzing can reveal vulnerabilities that traditional testing methods might overlook. Understanding the mechanics of fuzzing,\nsuch as the fuzzer and runner components, allows testers to tailor their approach to the specific needs of the application.\n\n#### Use-Case\n\nFuzzing is an invaluable technique for identifying vulnerabilities in\nsoftware. The benefits of fuzz testing include uncovering issues like\nbuffer overflows, crashes, and security vulnerabilities. To implement\nfuzzing, the fuzzer component can be customized to generate various \ntypes of inputs, such as numbers or characters. The runner component plays\na critical role in executing the target application with the generated inputs\nand monitoring its behavior.\n\n\n\n\n\n\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"cosmo","title":"Professional Précis","subtitle":"Author: (Keven M. Duverglas)"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
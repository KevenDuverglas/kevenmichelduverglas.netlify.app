---
title: "Professional Précis"
subtitle: "Author: (Keven M. Duverglas)"
---

# About the Author

Hello my name is Keven Michel Duverglas, and I am Sophmore at Allegheny. A fun fact about me is that I can speak three language.
I am looking forward to collaborating with everyone throughout the semester and get to know the dev-team well.


# Week 1

## SE1

#### Summary

There's an exploration of what exactly
"software engineering" means, and the reading distinguishes it not only
from fields like programming and computer science but also
shedding light on how it stands in relation to other disciplines
with "engineering" in their title. It also speaks on the matters regarding the 
growth of organizations and release new software. 

#### Reflection

I am firmly convinced that this book provides insights into crafting efficient code.
These insights offer practical advice on how to refine one's
coding practices for the long term. One of the standout aspects of the book is its emphasis
on reducing redundancy in code, which not only makes the code cleaner but also easier to maintain. 

#### Use-Case

This book provides the tools for us to run code, allowing Chasten to evaluate and utilize it within a test-case setting.

## FB1

#### Summary

The initial chapter introduces core concepts of software testing, addressing the necessity,
methods, and assessment of software testing. Using Python and interactive notebooks, readers
are familiarized with these principles. The chapter provides a basic my_sqrt() function, which
aims to compute the square root of a given number. A brief overview
of understanding Python's structure and syntax is provided, followed by a practical demonstration of
running the function. Readers can directly experiment with the
function and observe results, while also making edits to the provided content. And this can be done through a Jupyter 
Notebook.

#### Reflection

This chapter provided a comprehensive look into the world of software testing,
offering both theoretical knowledge and hands-on tools for practical implementation.
One of the intriguing parts for me was the example on testing the my_sqrt() function. Implementing a square root
function might appear elementary,
but the emphasis on the Newton–Raphson method highlighted the process behind it.

#### Use-Case

The first chapter of the Fuzzing book does a solid job of laying down the basics.
It sets the stage for the kind of deep thinking we'll need when we start building the
Chasten tool. By mixing theory with hands-on examples, readers get a good grasp of what's
ahead. This foundation is key, making sure everyone's on the same page as we dive into the
more complex parts of the book.
It's clear that this chapter is an essential starting point for everything that follows.


# Week 2

## SE2

#### Summary

The article contrasts programming with software engineering, emphasizing three primary distinctions:
time, scale, and trade-offs. Time emerges as a crucial factor, with software engineering often focusing
on projects with extended lifespans that shifts in technology or business trends.
Unlike standalone programming tasks, software engineering is inherently collaborative, 
challenges related to team dynamics, project
management, and organizational policies. As projects and teams expand, maintaining efficiency is vital.
Furthermore, the discipline of software engineering demands intricate decision-making. Engineers face
complex trade-offs, frequently operating within an environment of differing metrics.

#### Reflection

Reading this, I can resonate with the aspects of drawbacks and trade-offs in software engineering.
This is evident in class where many of my colleagues often have to decide which tasks are more crucial
to complete. Additionally, time significantly influences our work ethic and decision-making.
It's a constant balance of prioritizing immediate needs against long-term objectives.

#### Use-Case

During our software development, it's crucial to evaluate the trade-offs of our programming choices.
Understanding the advantages and disadvantages before deployment is vital to ensure we don't
introduce issues into our code, and also intergate time-keeping as a habit.

## FB2

#### Summary

To achieve nearly perfect code coverage, we utilize a technique known as fuzzing.
Fuzzing involves generating random characters to test various input scenarios.
This method helps generate potential outcomes for different functions,
like the provided example of the cgi_decode function.
Through this, we determine the necessary inputs
to achieve comprehensive code coverage in our tests.


#### Reflection

Implementing such testing mechanisms proves invaluable for identifying
maximum coverage using random fuzzing inputs. It's particularly effective
in discovering edge cases in extensive programs with myriad input possibilities.
However, it's a time-consuming approach. Hence,
it's crucial to employ this technique only for large-scale programs that can't be
manually vetted, ensuring optimal time management.

#### Use-case

For our chasten tool, incorporating these tests is paramount,
especially as we plan to introduce numerous features throughout the term.
It's crucial to ensure thorough coverage before releasing the software.
If we decide to implement this testing methodology, we must
be prepared to allocate substantial classroom time and personnel to it.

# Week 3

##SE3

#### Summary










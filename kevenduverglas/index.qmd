---
title: "Professional Précis"
subtitle: "Author: (Keven M. Duverglas)"
---

# About the Author

Hello my name is Keven Michel Duverglas, and I am Sophmore at Allegheny. A fun fact about me is that I can speak three language.
I am looking forward to collaborating with everyone throughout the semester and get to know the dev-team well.


# Week 1

## SE1

#### Summary

There's an exploration of what exactly
"software engineering" means, and the reading distinguishes it not only
from fields like programming and computer science but also
shedding light on how it stands in relation to other disciplines
with "engineering" in their title. It also speaks on the matters regarding the 
growth of organizations and release new software. 

#### Reflection

I am firmly convinced that this book provides insights into crafting efficient code.
These insights offer practical advice on how to refine one's
coding practices for the long term. One of the standout aspects of the book is its emphasis
on reducing redundancy in code, which not only makes the code cleaner but also easier to maintain. 

#### Use-Case

This book provides the tools for us to run code, allowing Chasten to evaluate and utilize it within a test-case setting.

## FB1

#### Summary

The initial chapter introduces core concepts of software testing, addressing the necessity,
methods, and assessment of software testing. Using Python and interactive notebooks, readers
are familiarized with these principles. The chapter provides a basic my_sqrt() function, which
aims to compute the square root of a given number. A brief overview
of understanding Python's structure and syntax is provided, followed by a practical demonstration of
running the function. Readers can directly experiment with the
function and observe results, while also making edits to the provided content. And this can be done through a Jupyter 
Notebook.

#### Reflection

This chapter provided a comprehensive look into the world of software testing,
offering both theoretical knowledge and hands-on tools for practical implementation.
One of the intriguing parts for me was the example on testing the my_sqrt() function. Implementing a square root
function might appear elementary,
but the emphasis on the Newton–Raphson method highlighted the process behind it.

#### Use-Case

The first chapter of the Fuzzing book does a solid job of laying down the basics.
It sets the stage for the kind of deep thinking we'll need when we start building the
Chasten tool. By mixing theory with hands-on examples, readers get a good grasp of what's
ahead. This foundation is key, making sure everyone's on the same page as we dive into the
more complex parts of the book.
It's clear that this chapter is an essential starting point for everything that follows.


# Week 2

## SE2

#### Summary

The article contrasts programming with software engineering, emphasizing three primary distinctions:
time, scale, and trade-offs. Time emerges as a crucial factor, with software engineering often focusing
on projects with extended lifespans that shifts in technology or business trends.
Unlike standalone programming tasks, software engineering is inherently collaborative, 
challenges related to team dynamics, project
management, and organizational policies. As projects and teams expand, maintaining efficiency is vital.
Furthermore, the discipline of software engineering demands intricate decision-making. Engineers face
complex trade-offs, frequently operating within an environment of differing metrics.

#### Reflection

Reading this, I can resonate with the aspects of drawbacks and trade-offs in software engineering.
This is evident in class where many of my colleagues often have to decide which tasks are more crucial
to complete. Additionally, time significantly influences our work ethic and decision-making.
It's a constant balance of prioritizing immediate needs against long-term objectives.

#### Use-Case

During our software development, it's crucial to evaluate the trade-offs of our programming choices.
Understanding the advantages and disadvantages before deployment is vital to ensure we don't
introduce issues into our code, and also intergate time-keeping as a habit.

## FB2

#### Summary

To achieve nearly perfect code coverage, we utilize a technique known as fuzzing.
Fuzzing involves generating random characters to test various input scenarios.
This method helps generate potential outcomes for different functions,
like the provided example of the cgi_decode function.
Through this, we determine the necessary inputs
to achieve comprehensive code coverage in our tests.

#### Reflection

Implementing such testing mechanisms proves invaluable for identifying
maximum coverage using random fuzzing inputs. It's particularly effective
in discovering edge cases in extensive programs with myriad input possibilities.
However, it's a time-consuming approach. Hence,
it's crucial to employ this technique only for large-scale programs that can't be
manually vetted, ensuring optimal time management.

#### Use-Case

For our chasten tool, incorporating these tests is paramount,
especially as we plan to introduce numerous features throughout the term.
It's crucial to ensure thorough coverage before releasing the software.
If we decide to implement this testing methodology, we must
be prepared to allocate substantial classroom time and personnel to it.

# Week 3

## SE3

#### Summary

This chapter delves into the infrastructure of a software engineering team, emphasizing the pivotal role of
teamwork in achieving remarkable results and highlighting the significance of self-awareness within the team.
The chapter discusses the trade-offs of working alone in software
development, including prolonged struggles and delayed error detection.
It also introduces the concept of collaborative nirvana, focusing on three
pillars of social interaction: humility, respect, and trust.
The action items suggested include regular team meetings and check-ins,
peer mentoring and knowledge sharing, as well as the importance of acknowledging
each team member's strengths, celebrating success, and learning from failures.

#### Reflection

This chapter underscores the critical importance of collaboration and self-awareness
in software engineering teams. It serves as a reminder that working in isolation can
lead to challenges and hinder progress.
Embracing humility, respect, and trust as guiding principles for social interaction
can unlock the full potential of teamwork.

#### Use-Case

The insights and recommendations from this chapter can be applied
in various scenarios within a software engineering team. For instance,
teams can implement regular meetings and check-ins to foster communication
and collaboration. Peer mentoring and knowledge sharing can be encouraged to
facilitate skill development and information exchange. Additionally,
acknowledging the strengths of each team member,
celebrating achievements, and using failures as opportunities for
learning can help create a positive and productive team culture.

## FB3

#### Summary

Fuzzing is a dynamic testing technique employed to discover defects by generating
a wide array of random inputs and subjecting them relentlessly to a target application.
The primary aim is to stress-test the software and unearth unexpected vulnerabilities.
This chapter delves into the benefits of fuzzing,
the roles of the fuzzer and runner components, and the advantages of applying fuzz testing to external programs.

#### Reflection

The concept of fuzzing is a powerful tool in the software testing arsenal.
By inundating an application with diverse and often unpredictable inputs,
fuzzing can reveal vulnerabilities that traditional testing methods might overlook. Understanding the mechanics of fuzzing,
such as the fuzzer and runner components, allows testers to tailor their approach to the specific needs of the application.

#### Use-Case

Fuzzing is an invaluable technique for identifying vulnerabilities in
software. The benefits of fuzz testing include uncovering issues like
buffer overflows, crashes, and security vulnerabilities. To implement
fuzzing, the fuzzer component can be customized to generate various 
types of inputs, such as numbers or characters. The runner component plays
a critical role in executing the target application with the generated inputs
and monitoring its behavior.









